<h1>动态规划</h1>

<h2>用途</h2>用于解决最优化问题的算法思想，特别适用于可以分解为子问题的复杂问题  
<h2>优点</h2>通过存储已经解决的子问题的结果，可以避免重复计算，从而提高算法的效率

<h2>步骤</h2>
1. <strong>定义状态</strong>：明确问题的元素用哪种状态来表示（通常用<strong> 数组</strong>、<strong>表格 </strong>来存储每个状态的结果）<br>
2. <strong>状态转移方程</strong>：构建当前状态与之前状态的关系，用<strong>递推公式</strong>来描述<br>
3. <strong>边界条件</strong>：设定初始条件，用最简单的情况，来作为后续状态的基础<br>
4. <strong>计算结果</strong>：通过状态转移方程，从边界条件开始，计算到最终状态

<h2>经典问题</h2>
1. 斐波那契数列<br>
2. 背包问题<br>
3. 最小路径和<br>
4. 最长公共子序列
<h3>斐波那契数列</h3>
定义：F(n) = F(n-1) + F(n-2)<br>
边界条件：F(0) = 0, F(1) = 1
<h3>背包问题</h3>
定义：给定一组物品，每个物品有重量和价值，在不超过背包容量的情况下，选择物品使得总价值最大<br>
状态表示：dp[i][j] 表示前 i 个物品在容量为 j 的背包中能获得的最大价值
<h3>最小路径和</h3>
定义：给定一个网格，从左上角到右下角的路径，求最小路径和<br>
状态转移方程：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
<h3>最长公共子序列</h3>
定义：给定两个字符串，找出它们的最长公共子序列的长度<br>
状态表示：dp[i][j] 表示第一个字符串前 i 个字符和第二个字符串前 j 个字符的最长公共子序列的长度
<h2>代码示例</h2>
<h3>斐波那契数列</h3>
<pre><code>
#include <stdio.h>

int fibonacci(int n) {
    if (n <= 1) return n;
    int dp[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2]; // 状态转移方程
    }
    return dp[n];
}

int main() {
    int n;
    printf("请输入一个非负整数：");
    scanf("%d", &n);
    printf("斐波那契数列的第 %d 项是：%d\n", n, fibonacci(n));
    return 0;
}</code></pre>
