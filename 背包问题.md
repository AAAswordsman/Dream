<h1>背包问题</h1>
<h2>0-1 背包问题</h2>
<h3>描述</h3>
给定一个背包，它有固定的容量 W。现在有 n 个物品，每个物品有一定的重量 weight[i] 和价值 value[i]。每种物品只能选择要放入还是不放入背包。目标是找到一种放入物品的组合，使得在不超过背包容量 W 的前提下，背包中的物品总价值最大。
<h3>解法</h3>
<strong>通过构造一个二维数组 dp[i][j] 来存储子问题的解</strong>，其中 i 表示当前考虑的物品，j 表示背包容量，若有4个物品，背包容量为10，则从只考虑第1个物品，背包容量从0~10，再只考虑前2个物品，背包容量为0~10，继续类推，直到考虑4个物品，背包容量为10，<strong>在这个过程中，将得到每个情况下的最优解</strong>。<br><br>
<strong>状态定义：</strong>dp[i][j] 表示在前 i 个物品中选择，且背包容量为 j 时的最大价值<br><br>

<strong>状态转移方程：</strong>

如果不选第 i 个物品，则 dp[i][j] = dp[i-1][j]（不选第i个物品，结果等于i-1时的最优解）

如果选择第 i 个物品，则 dp[i][j] = dp[i-1][j-weight[i]] + value[i]（选择了第i个物品，背包容量减去了i的重量，结果为，背包剩下的空间装前i-1个物品的最优解，那么总价值就会带上第i个物品的价值）

综合两种情况，得到：

dp[i][j]=max⁡(dp[i−1][j],dp[i−1][j−weight[i]]+value[i])（i个物品的最优解从是否选i的两种情况下对比）

<strong>边界条件：</strong>

dp[0][j] = 0 （当没有物品时，总价值为 0）
<h3>思考</h3>
我们或许会担心，动态规划下的全局最优解真的得益于局部最优解吗？<br>
我认为这种关联得益于状态转移方程，如果全局最优解可以由局部最优解推导出来，那么每一步都能得出局部最优解是自然而然的。<br>
动态规划关心的并不是局部最优解，而是全局最优解如何推导而来，通过累积子问题的解，探索可能的路径来保证全局最优解的构建。
<h3>代码算法说明</h3>
该代码通过状态i由状态i-1来决定，来限制第i个物品只能取一次
<h3>代码</h3>
<pre><code>#include &lt;stdio.h&gt;
#define MAX_ITEMS 100
#define MAX_CAPACITY 1000
<br>
int max(int a, int b) {
    return (a > b) ? a : b;
}
<br>
int knapsack(int n, int W, int weight[], int value[]) {
    int dp[MAX_ITEMS + 1][MAX_CAPACITY + 1] = {0};<br>
  <br>
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= W; j++) {
            if (weight[i-1] <= j) { //当第i个物品的重量小于等于背包容量才考虑i
                dp[i][j] = max(dp[i-1][j], dp[i-1][j - weight[i-1]] + value[i-1]); //比较是否选择i时的大小
            } else {
                dp[i][j] = dp[i-1][j]; //背包不够i的大小，不考虑i
            }
        }
    }<br>
    return dp[n][W];
}
<br>
int main() {
    int n = 4; // 物品数量
    int W = 10; // 背包容量
    int weight[] = {2, 3, 4, 5}; // 各物品的重量
    int value[] = {3, 4, 5, 6}; // 各物品的价值
<br>
    int max_value = knapsack(n, W, weight, value);
    printf("背包最大价值为：%d\n", max_value);
<br>
    return 0;
}
</code></pre>
<h3>优化</h3>
<strong>状态转移方程：</strong><br><br>

dp[j]=max(dp[j],dp[j−w[i]]+v[i])

<strong>边界条件：</strong>

dp[0] = 0
<h3>代码算法说明</h3>
该代码将二维数组降到一维，通过倒序来满足每个物品只能取一次，避免状态的叠加使物品重复取用
<h3>代码</h3>
<pre><code>#include <stdio.h>
<br>
int max(int a, int b) {
    return (a > b) ? a : b;
}
<br>
int knapsack(int n, int W, int weight[], int value[]) {
    int dp[W + 1] = {0};
<br>
    for (int i = 0; i < n; i++) {
        for (int j = W; j >= weight[i]; j--) {
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); //考虑容量为j时是否装入第i个物品
        }
    }
<br>
    return dp[W];
}
<br>
int main() {
    int n = 4; // 物品数量
    int W = 10; // 背包容量
    int weight[] = {2, 3, 4, 5}; // 各物品的重量
    int value[] = {3, 4, 5, 6}; // 各物品的价值
<br>
    int max_value = knapsack(n, W, weight, value);
    printf("背包最大价值为：%d\n", max_value);
<br>
    return 0;
}
</code></pre>
<h2>完全背包问题</h2>
<h3>描述</h3>
每个物品可以选择多次，其他条件与01背包问题相同
<h3>解法</h3>
<strong>状态转移方程：</strong><br><br>

dp[j]=max(dp[j],dp[j−w[i]]+v[i])

<strong>边界条件：</strong>

dp[0] = 0
<h3>代码算法说明</h3>
通过正序使得状态可以叠加，达到了物品可以多次选择的效果，但没有限制每个物品可以拿的次数
<h3>代码</h3>
<pre><code>#include <stdio.h>
<br>
int knapsack_complete(int weights[], int values[], int n, int W) {
    int dp[W + 1] = {0};  // 初始化dp数组为0
<br>
    // 遍历每一个物品
    for (int i = 0; i < n; i++) {
        // 完全背包问题的特点在于内层循环是正序遍历
        for (int j = weights[i]; j <= W; j++) {
            // 状态转移方程：dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
            if (dp[j] < dp[j - weights[i]] + values[i]) {
                dp[j] = dp[j - weights[i]] + values[i];
            }
        }
    }
    return dp[W];  // 返回容量为 W 时的最大价值
}
<br>
int main() {
    int weights[] = {1, 3, 4};  // 物品的重量
    int values[] = {15, 50, 60};  // 物品的价值
    int W = 8;  // 背包容量
    int n = sizeof(weights) / sizeof(weights[0]);  // 物品数量
<br>
    int max_value = knapsack_complete(weights, values, n, W);
    printf("最大价值: %d\n", max_value);
<br>
    return 0;
}
</code></pre>
